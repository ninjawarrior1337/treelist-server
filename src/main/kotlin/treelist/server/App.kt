/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package treelist.server

import com.google.gson.Gson
import com.sun.nio.file.ExtendedWatchEventModifier
import io.github.cdimascio.dotenv.Dotenv
import io.jooby.MediaType
import io.jooby.ServerOptions
import io.jooby.runApp
import io.netty.handler.codec.http.cors.CorsConfig
import io.netty.handler.codec.http.cors.CorsConfigBuilder
import io.netty.handler.codec.http.cors.CorsHandler
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.jaudiotagger.audio.exceptions.CannotReadException
import java.io.FileReader
import java.nio.file.*
import java.nio.file.FileVisitResult
import java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY
import java.nio.file.StandardWatchEventKinds.ENTRY_DELETE
import java.nio.file.StandardWatchEventKinds.ENTRY_CREATE
import java.io.IOException
import java.nio.file.attribute.BasicFileAttributes
import java.nio.file.SimpleFileVisitor
import java.nio.file.Files


private val watcher = FileSystems.getDefault().newWatchService()
private val dotenv = Dotenv.configure().ignoreIfMissing().load()

val musicDir = dotenv.get("MUSIC_DIR", "./music")
val configDir = dotenv.get("CONFIG_DIR", "./config")

fun getAudioFileFromId(id: String): AudioFile
{
    val audioFiles = Gson().fromJson(FileReader(Paths.get("$configDir/db.json").toFile()), Array<AudioFile>::class.java)

    return audioFiles.first {
        id == it.hash
    }.copy()

    //We use copy to run the init methods of the class.
}

fun refreshDB()
{
    val files = mutableListOf<AudioFile>()

    Files.walk(Paths.get(musicDir))
            .filter {
                Files.isRegularFile(it)
            }
            .forEach {
                val audioFile: AudioFile? =
                    try {
                        AudioFile(it.toAbsolutePath().normalize().toString())
                    }
                    catch (e: CannotReadException)
                    {
                        null
                    }
                if (audioFile != null) {
                    files.add(audioFile)
                }
            }
    val fw = Files.newBufferedWriter(Paths.get("$configDir/db.json"))
    fw.write(files.toString())
    fw.close()
}

@Throws(IOException::class)
private fun registerRecursive(root: Path) {
    // register all subfolders
    Files.walkFileTree(root, object : SimpleFileVisitor<Path>() {
        @Throws(IOException::class)
        override fun preVisitDirectory(dir: Path, attrs: BasicFileAttributes): FileVisitResult {
            dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY)
            return FileVisitResult.CONTINUE
        }
    })
}

fun main(args: Array<String>)
{
    //Print Info
    print("Music Dir: $musicDir\n")
    print("Config Dir: $configDir\n")
    //Register Watcher
    registerRecursive(Paths.get(musicDir))

    GlobalScope.launch {
        while (true)
        {
            val wKey = watcher.take()
            val events = wKey.pollEvents()

            if(events.size >= 1) {
                events.clear()
                delay(1000)
                refreshDB()
            }

            wKey.reset()
        }
    }

    runApp(args)
    {
        refreshDB()
        get("/song/{id}") {
            val audioFile = getAudioFileFromId(ctx.path("id").value())

            ctx.setResponseType("audio/mpeg")
                .send(Paths.get(audioFile.path))
        }

        get("/song/art/{id}")
        {
            val audioFile = getAudioFileFromId(ctx.path("id").value())
            print(audioFile.path)
            val artwork = audioFile.artwork
            if(artwork != null)
            {
                ctx.send(audioFile.artwork!!)
            }
            else
            {
                ctx.setResponseCode(404).send("Artwork not found")
            }
        }

        decorator {
            ctx.setResponseHeader("Access-Control-Allow-Origin", "*")
            next.apply(ctx)
        }
        get("/db/get")
        {
            ctx.send(Paths.get("$configDir/db.json"))
        }

        decorator {
            ctx.setResponseHeader("Access-Control-Allow-Origin", "*")
            next.apply(ctx)
        }
        get("/db/gen")
        {
            coroutine {
                refreshDB()
                ctx.setResponseType(MediaType.json)
                        .send(Paths.get("$configDir/db.json"))
            }
        }

        setServerOptions(ServerOptions()
                .setPort(5000)
        )
    }
}